INFO:root:Using the parsing module to parse 'source'...
INFO:root:Successfully loaded source (tests/src/demo.py):
# Should have type: (t0, t1) -> str
def x(y,z):
	return "hi"

# Should have type: int
flops = 4

# Flops should be shadowed below:
# Should have type: t0 -> t0
def giga(flops):
	return flops

# The S combinator
# Should have type (t0, t1) -> t0
def S(x,y):
	return x
 
# hack the gibson with higher order functions
# Should have type: (t2, t3) -> ((t0, t1) -> t0)
def hack(the, gibson):
	return S

# Function calling

S(1,"hi")

hack(1,2)

giga("infinity")

x(None, False)

## Now let's play with classes

class A:
	x = lambda x: x+1
	y = B()

class B:
	y = A()
	z = C()

class C:
	x = A()
	Z = "penguins"

a = A()
b = B()
c = C()

INFO:root:Parsed source. Raw AST is:
Module(body=[FunctionDef(name='x', args=arguments(args=[Name(id='y', ctx=Param()), Name(id='z', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Str(s='hi'))], decorator_list=[]), Assign(targets=[Name(id='flops', ctx=Store())], value=Num(n=4)), FunctionDef(name='giga', args=arguments(args=[Name(id='flops', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='flops', ctx=Load()))], decorator_list=[]), FunctionDef(name='S', args=arguments(args=[Name(id='x', ctx=Param()), Name(id='y', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='x', ctx=Load()))], decorator_list=[]), FunctionDef(name='hack', args=arguments(args=[Name(id='the', ctx=Param()), Name(id='gibson', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='S', ctx=Load()))], decorator_list=[]), Expr(value=Call(func=Name(id='S', ctx=Load()), args=[Num(n=1), Str(s='hi')], keywords=[], starargs=None, kwargs=None)), Expr(value=Call(func=Name(id='hack', ctx=Load()), args=[Num(n=1), Num(n=2)], keywords=[], starargs=None, kwargs=None)), Expr(value=Call(func=Name(id='giga', ctx=Load()), args=[Str(s='infinity')], keywords=[], starargs=None, kwargs=None)), Expr(value=Call(func=Name(id='x', ctx=Load()), args=[Name(id='None', ctx=Load()), Name(id='False', ctx=Load())], keywords=[], starargs=None, kwargs=None)), ClassDef(name='A', bases=[], body=[Assign(targets=[Name(id='x', ctx=Store())], value=Lambda(args=arguments(args=[Name(id='x', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Num(n=1)))), Assign(targets=[Name(id='y', ctx=Store())], value=Call(func=Name(id='B', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))], decorator_list=[]), ClassDef(name='B', bases=[], body=[Assign(targets=[Name(id='y', ctx=Store())], value=Call(func=Name(id='A', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='z', ctx=Store())], value=Call(func=Name(id='C', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))], decorator_list=[]), ClassDef(name='C', bases=[], body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='A', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='Z', ctx=Store())], value=Str(s='penguins'))], decorator_list=[]), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='A', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Name(id='B', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='C', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])
INFO:root:Traversing our AST...
DEBUG:root:typtyptyptyp = (tuple(t3)(t4) -> t3)
INFO:root:initial sub: {}
INFO:root:self applied = str
INFO:root:other applied = t4
INFO:root:sub loop = {t4 : str,}
INFO:root:self applied = int
INFO:root:other applied = t3
INFO:root:sub loop = {t3 : int,t4 : str,}
INFO:root:For typ = (tuple(t3)(t4) -> t3)
INFO:root:For self = (tuple(int)(str) -> t7)
INFO:root:Merging s1 ({t3 : int,t4 : str,}) and s2 ({t7 : t3,})
INFO:root:Merged s1 and s2: {t7 : t3,t3 : int,t4 : str,}
DEBUG:root:sub3 = {t7 : t3,t3 : int,t4 : str,}
DEBUG:root:applied-type = (tuple(int)(str) -> t7)
DEBUG:root:unified-type = (tuple(int)(str) -> int)
DEBUG:root:typtyptyptyp = (tuple(t5)(t6) -> (tuple(t3)(t4) -> t3))
INFO:root:initial sub: {}
INFO:root:self applied = int
INFO:root:other applied = t6
INFO:root:sub loop = {t6 : int,}
INFO:root:self applied = int
INFO:root:other applied = t5
INFO:root:sub loop = {t6 : int,t5 : int,}
INFO:root:For typ = (tuple(t5)(t6) -> (tuple(t3)(t4) -> t3))
INFO:root:For self = (tuple(int)(int) -> t8)
INFO:root:Merging s1 ({t6 : int,t5 : int,}) and s2 ({t8 : (tuple(t3)(t4) -> t3),})
INFO:root:Merged s1 and s2: {t6 : int,t8 : (tuple(t3)(t4) -> t3),t5 : int,}
DEBUG:root:sub3 = {t6 : int,t8 : (tuple(t3)(t4) -> t3),t5 : int,}
DEBUG:root:applied-type = (tuple(int)(int) -> t8)
DEBUG:root:unified-type = (tuple(int)(int) -> (tuple(t3)(t4) -> t3))
DEBUG:root:typtyptyptyp = (tuple(t2) -> t2)
INFO:root:initial sub: {}
INFO:root:self applied = str
INFO:root:other applied = t2
INFO:root:sub loop = {t2 : str,}
INFO:root:For typ = (tuple(t2) -> t2)
INFO:root:For self = (tuple(str) -> t9)
INFO:root:Merging s1 ({t2 : str,}) and s2 ({t9 : t2,})
INFO:root:Merged s1 and s2: {t9 : t2,t2 : str,}
DEBUG:root:sub3 = {t9 : t2,t2 : str,}
DEBUG:root:applied-type = (tuple(str) -> t9)
DEBUG:root:unified-type = (tuple(str) -> str)
DEBUG:root:typtyptyptyp = (tuple(t0)(t1) -> str)
INFO:root:initial sub: {}
INFO:root:self applied = bool
INFO:root:other applied = t1
INFO:root:sub loop = {t1 : bool,}
INFO:root:self applied = None
INFO:root:other applied = t0
INFO:root:sub loop = {t0 : None,t1 : bool,}
INFO:root:For typ = (tuple(t0)(t1) -> str)
INFO:root:For self = (tuple(None)(bool) -> t10)
INFO:root:Merging s1 ({t0 : None,t1 : bool,}) and s2 ({t10 : str,})
INFO:root:Merged s1 and s2: {t10 : str,t0 : None,t1 : bool,}
DEBUG:root:sub3 = {t10 : str,t0 : None,t1 : bool,}
DEBUG:root:applied-type = (tuple(None)(bool) -> t10)
DEBUG:root:unified-type = (tuple(None)(bool) -> str)
DEBUG:root:typtyptyptyp = t11
DEBUG:root:sub3 = {t11 : (tuple -> t12),}
DEBUG:root:applied-type = (tuple -> t12)
DEBUG:root:unified-type = (tuple -> t12)
DEBUG:root:typtyptyptyp = t13
DEBUG:root:sub3 = {t13 : (tuple -> t14),}
DEBUG:root:applied-type = (tuple -> t14)
DEBUG:root:unified-type = (tuple -> t14)
DEBUG:root:typtyptyptyp = t15
DEBUG:root:sub3 = {t15 : (tuple -> t16),}
DEBUG:root:applied-type = (tuple -> t16)
DEBUG:root:unified-type = (tuple -> t16)
INFO:root:Analyzed Tree:
INFO:root:  tests/src/demo.py
    x : (tuple(t0)(t1) -> str)
      
        y : t0
        z : t1
      return
        "hi" : str
    
      flops : int
      4 : int
    giga : (tuple(t2) -> t2)
      
        flops : t2
      return
        flops : t2
    S : (tuple(t3)(t4) -> t3)
      
        x : t3
        y : t4
      return
        x : t3
    hack : (tuple(t5)(t6) -> (tuple(t3)(t4) -> t3))
      
        the : t5
        gibson : t6
      return
        S : (tuple(t3)(t4) -> t3)
    
      S : (tuple(int)(str) -> int)
    
      hack : (tuple(int)(int) -> (tuple(t3)(t4) -> t3))
    
      giga : (tuple(str) -> str)
    
      x : (tuple(None)(bool) -> str)
    
    
    
    
      a : (tuple -> t12)
      A : (tuple -> t12)
    
      b : (tuple -> t14)
      B : (tuple -> t14)
    
      c : (tuple -> t16)
      C : (tuple -> t16)

