INFO:root:Using the parsing module to parse 'source'...
INFO:root:Successfully loaded source (tests/src/functions.py):

# Basic
def hi(y,z): # : (a{}, b{}) -> str
	return "hi"

# Shadowing: shadow n as a parameter
n = 4 # : int

def shadow(n): # : (a{}) -> a{}
	return n

n # : int

# Returning a function object
def f(): return hi # : () -> ((a{}, b{}) -> str)

# Multiple return types

# def multi(p):
# 	if p: return 1
# 	else: return 2

# Function application to parameters in the body changes the type of the parameters.

def S(x,y):  return x      # : (a{}, b{}) -> a{}
def S2(x,y): return S(x,y) # : (a{}, b{}) -> a{}

# Function calls:

a = hi(1,2)       # : str
b = shadow("ret") # : str
c = S("s",2)      # : str
c = S2(2,"s")     # : int
d = S(hi,shadow)  # : t3{...} (hi function type)

# Type errors:
# Parameters too few or many:
hi(1,2,3) # : error: conflicting params
hi(1)     # : error: conflicting params
# 

INFO:root:Parsed source. Raw AST is:
Module(body=[FunctionDef(name='hi', args=arguments(args=[Name(id='y', ctx=Param()), Name(id='z', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Str(s='hi'))], decorator_list=[]), Assign(targets=[Name(id='n', ctx=Store())], value=Num(n=4)), FunctionDef(name='shadow', args=arguments(args=[Name(id='n', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='n', ctx=Load()))], decorator_list=[]), Expr(value=Name(id='n', ctx=Load())), FunctionDef(name='f', args=arguments(args=[], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='hi', ctx=Load()))], decorator_list=[]), FunctionDef(name='S', args=arguments(args=[Name(id='x', ctx=Param()), Name(id='y', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='x', ctx=Load()))], decorator_list=[]), FunctionDef(name='S2', args=arguments(args=[Name(id='x', ctx=Param()), Name(id='y', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Call(func=Name(id='S', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[], starargs=None, kwargs=None))], decorator_list=[]), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='hi', ctx=Load()), args=[Num(n=1), Num(n=2)], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Name(id='shadow', ctx=Load()), args=[Str(s='ret')], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='S', ctx=Load()), args=[Str(s='s'), Num(n=2)], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='S2', ctx=Load()), args=[Num(n=2), Str(s='s')], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Name(id='S', ctx=Load()), args=[Name(id='hi', ctx=Load()), Name(id='shadow', ctx=Load())], keywords=[], starargs=None, kwargs=None)), Expr(value=Call(func=Name(id='hi', ctx=Load()), args=[Num(n=1), Num(n=2), Num(n=3)], keywords=[], starargs=None, kwargs=None)), Expr(value=Call(func=Name(id='hi', ctx=Load()), args=[Num(n=1)], keywords=[], starargs=None, kwargs=None))])
INFO:root:Traversing our AST...
INFO:root:Builtins: {'self': self<type 'object'>}
DEBUG:root:env: {'self': self<type 'object'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}}
DEBUG:root:env_scoped: {'self': self<type 'object'>, 'z': t1{}, 'y': t0{}, 'return': <type 'str'>}
DEBUG:root:env: {'self': self<type 'object'>, 'n': <type 'int'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}}
DEBUG:root:env_scoped: {'self': self<type 'object'>, 'n': t4{}, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'return': t4{}}
DEBUG:root:env: {'self': self<type 'object'>, 'n': <type 'int'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'f': t8{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple7[]}, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}}
DEBUG:root:env_scoped: {'self': self<type 'object'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'n': <type 'int'>, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}, 'return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}}
DEBUG:root:env: {'S': t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}, 'self': self<type 'object'>, 'n': <type 'int'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'f': t8{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple7[]}, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}}
DEBUG:root:env_scoped: {'self': self<type 'object'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'n': <type 'int'>, 'f': t8{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple7[]}, 'x': t9{}, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}, 'y': t10{}, 'return': t9{}}
DEBUG:root:Given type: t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}
DEBUG:root:Applied type: t17{'*return': t9{}, '*params': tuple16[t13{}, t14{}]}
DEBUG:root:Substitution: [t14 >> t10{},t9 >> t9{},t13 >> t9{},]
DEBUG:root:Unified type: t17{'*return': t9{}, '*params': tuple16[t9{}, t10{}]}
DEBUG:root:env: {'S': t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}, 'self': self<type 'object'>, 'n': <type 'int'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'f': t8{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple7[]}, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}, 'S2': t18{'*return': t9{}, '*params': tuple15[t9{}, t10{}]}}
DEBUG:root:env_scoped: {'S': t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}, 'self': self<type 'object'>, 'hi': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, 'n': <type 'int'>, 'f': t8{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple7[]}, 'x': t9{}, 'shadow': t6{'*return': t4{}, '*params': tuple5[t4{}]}, 'y': t10{}, 'return': t9{}}
DEBUG:root:Given type: t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
DEBUG:root:Applied type: t20{'*return': <type 'str'>, '*params': tuple19[<type 'int'>, <type 'int'>]}
DEBUG:root:Substitution: [t0 >> <type 'int'>,t1 >> <type 'int'>,]
DEBUG:root:Unified type: t20{'*return': <type 'str'>, '*params': tuple19[<type 'int'>, <type 'int'>]}
DEBUG:root:Given type: t6{'*return': t4{}, '*params': tuple5[t4{}]}
DEBUG:root:Applied type: t22{'*return': t4{}, '*params': tuple21[<type 'str'>]}
DEBUG:root:Substitution: [t4 >> <type 'str'>,]
DEBUG:root:Unified type: t22{'*return': <type 'str'>, '*params': tuple21[<type 'str'>]}
DEBUG:root:Given type: t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}
DEBUG:root:Applied type: t24{'*return': t9{}, '*params': tuple23[<type 'str'>, <type 'int'>]}
DEBUG:root:Substitution: [t10 >> <type 'int'>,t9 >> <type 'str'>,]
DEBUG:root:Unified type: t24{'*return': <type 'str'>, '*params': tuple23[<type 'str'>, <type 'int'>]}
DEBUG:root:Given type: t18{'*return': t9{}, '*params': tuple15[t9{}, t10{}]}
DEBUG:root:Applied type: t26{'*return': t9{}, '*params': tuple25[<type 'int'>, <type 'str'>]}
DEBUG:root:Substitution: [t10 >> <type 'str'>,t9 >> <type 'int'>,]
DEBUG:root:Unified type: t26{'*return': <type 'int'>, '*params': tuple25[<type 'int'>, <type 'str'>]}
DEBUG:root:Given type: t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}
DEBUG:root:Applied type: t28{'*return': t9{}, '*params': tuple27[t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, t6{'*return': t4{}, '*params': tuple5[t4{}]}]}
DEBUG:root:Substitution: [t10 >> t6{'*return': t4{}, '*params': tuple5[t4{}]},t9 >> t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]},]
DEBUG:root:Unified type: t28{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple27[t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, t6{'*return': t4{}, '*params': tuple5[t4{}]}]}
DEBUG:root:Given type: t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
DEBUG:root:Applied type: t30{'*return': <type 'str'>, '*params': tuple29[<type 'int'>, <type 'int'>, <type 'int'>]}
DEBUG:root:Substitution: [tuple29 >> <<Type Error: Conflicting types: tuple29[<type 'int'>, <type 'int'>, <type 'int'>] and tuple2[t0{}, t1{}]>>,]
DEBUG:root:Unified type: t30{'*return': <type 'str'>, '*params': <<Type Error: Conflicting types: tuple29[<type 'int'>, <type 'int'>, <type 'int'>] and tuple2[t0{}, t1{}]>>}
DEBUG:root:Given type: t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
DEBUG:root:Applied type: t32{'*return': <type 'str'>, '*params': tuple31[<type 'int'>]}
DEBUG:root:Substitution: [tuple31 >> <<Type Error: Conflicting types: tuple31[<type 'int'>] and tuple2[t0{}, t1{}]>>,]
DEBUG:root:Unified type: t32{'*return': <type 'str'>, '*params': <<Type Error: Conflicting types: tuple31[<type 'int'>] and tuple2[t0{}, t1{}]>>}
INFO:root:Analyzed Tree:
INFO:root:  tests/src/functions.py
    hi : t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
      Parameters : tuple2[t0{}, t1{}]
        y : t0{}
        z : t1{}
      return
        "hi" : <type 'str'>
    Assign
      n : <type 'int'>
      4 : <type 'int'>
    shadow : t6{'*return': t4{}, '*params': tuple5[t4{}]}
      Parameters : tuple5[t4{}]
        n : t4{}
      return
        n : t4{}
    
      n : <type 'int'>
    f : t8{'*return': t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}, '*params': tuple7[]}
      Parameters : tuple7[]
      return
        hi : t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
    S : t12{'*return': t9{}, '*params': tuple11[t9{}, t10{}]}
      Parameters : tuple11[t9{}, t10{}]
        x : t9{}
        y : t10{}
      return
        x : t9{}
    S2 : t18{'*return': t9{}, '*params': tuple15[t9{}, t10{}]}
      Parameters : tuple15[t9{}, t10{}]
        x : t9{}
        y : t10{}
      return
        S : t9{}
    Assign
      a : <type 'str'>
      hi : <type 'str'>
    Assign
      b : <type 'str'>
      shadow : <type 'str'>
    Assign
      c : <type 'str'>
      S : <type 'str'>
    Assign
      c : <type 'int'>
      S2 : <type 'int'>
    Assign
      d : t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
      S : t3{'*return': <type 'str'>, '*params': tuple2[t0{}, t1{}]}
    
      hi : <<Type Error: Conflicting types: tuple29[<type 'int'>, <type 'int'>, <type 'int'>] and tuple2[t0{}, t1{}]>>
    
      hi : <<Type Error: Conflicting types: tuple31[<type 'int'>] and tuple2[t0{}, t1{}]>>

