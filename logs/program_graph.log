INFO:root:Using the parsing module to parse 'source'...
INFO:root:Successfully loaded source (tests/src/demo.py):
## Demo.py --- a demonstration of python type inference
## Jay R Bolton

## Assignment and primitives
x = y ## type error: y undefined
y = 1
z = y
y = "str"

## Function definition

# Should have type equivalent to (t0,t1)->t0
# Type of parameter x will shadow global x
def S(x,y):  return x 

# return a function object
def f(): return S

# take a function object and apply it
def g(x,y,func): return func(x,y)

## Function calls

q = S(y,z) ## Type should infer to int
q = S(z) ## Error: conflicting parameters
q = S(x,x) ## X is still undefined
q = S(y,z,x) ## Error: conflicing parameters

s = f()
r = g("hi",42,S)

## Class definition

#class A(object):
#	z = 1
#
#a = A()

## Attribute reference

INFO:root:Parsed source. Raw AST is:
Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Name(id='y', ctx=Load())), Assign(targets=[Name(id='y', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='z', ctx=Store())], value=Name(id='y', ctx=Load())), Assign(targets=[Name(id='y', ctx=Store())], value=Str(s='str')), FunctionDef(name='S', args=arguments(args=[Name(id='x', ctx=Param()), Name(id='y', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='x', ctx=Load()))], decorator_list=[]), FunctionDef(name='f', args=arguments(args=[], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Name(id='S', ctx=Load()))], decorator_list=[]), FunctionDef(name='g', args=arguments(args=[Name(id='x', ctx=Param()), Name(id='y', ctx=Param()), Name(id='func', ctx=Param())], vararg=None, kwarg=None, defaults=[]), body=[Return(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[], starargs=None, kwargs=None))], decorator_list=[]), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='S', ctx=Load()), args=[Name(id='y', ctx=Load()), Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='S', ctx=Load()), args=[Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='S', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='x', ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='S', ctx=Load()), args=[Name(id='y', ctx=Load()), Name(id='z', ctx=Load()), Name(id='x', ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Name(id='f', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Name(id='g', ctx=Load()), args=[Str(s='hi'), Num(n=42), Name(id='S', ctx=Load())], keywords=[], starargs=None, kwargs=None))])
INFO:root:Traversing our AST...
DEBUG:root:Env: {'y': <<Type Error: Undefined>>}
DEBUG:root:Env: {'x': <<Type Error: Undefined>>, 'y': <<Type Error: Undefined>>}
DEBUG:root:Env: {'x': <<Type Error: Undefined>>, 'y': <type 'int'>}
DEBUG:root:Env: {'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'int'>}
DEBUG:root:Env: {'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>}
DEBUG:root:Env: {'x': object0{}, 'z': <type 'int'>}
DEBUG:root:Env: {'x': object0{}, 'z': <type 'int'>, 'y': object1{}}
DEBUG:root:Env: {'x': object0{}, 'z': <type 'int'>, 'y': object1{}, 'return': object0{}}
DEBUG:root:return type: object0{}
DEBUG:root:Env: {'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>}
DEBUG:root:Env: {'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}}
DEBUG:root:return type: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Env: {'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>}
DEBUG:root:Env: {'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': object6{}, 'z': <type 'int'>}
DEBUG:root:Env: {'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': object6{}, 'z': <type 'int'>, 'y': object7{}}
DEBUG:root:Env: {'func': object8{}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': object6{}, 'z': <type 'int'>, 'y': object7{}}
DEBUG:root:Given type: object8{}
DEBUG:root:Environment: {'func': object8{}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': object6{}, 'z': <type 'int'>, 'y': object7{}}
DEBUG:root:Arg types: [object7{}, object6{}]
DEBUG:root:Applied type: object11{'*return': object10{}, '*params': tuple9[object7{}, object6{}]}
DEBUG:root:Unifying object: object8{} with: object11{'*return': object10{}, '*params': tuple9[object7{}, object6{}]}
DEBUG:root:Sub is: [object8 >> object11{'*return': object10{}, '*params': tuple9[object7{}, object6{}]},]
DEBUG:root:Applying sub to: object8{}
DEBUG:root:Unified type: object11{'*return': object10{}, '*params': tuple9[object7{}, object6{}]}
DEBUG:root:Env: {'func': object8{}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': object6{}, 'z': <type 'int'>, 'y': object7{}, 'return': object10{}}
DEBUG:root:return type: object10{}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>}
DEBUG:root:Given type: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Environment: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>}
DEBUG:root:Arg types: [<type 'int'>, <type 'str'>]
DEBUG:root:Applied type: object16{'*return': object15{}, '*params': tuple14[<type 'int'>, <type 'str'>]}
DEBUG:root:Unifying object: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]} with: object16{'*return': object15{}, '*params': tuple14[<type 'int'>, <type 'str'>]}
DEBUG:root:Unifying *return: object0{} with object15{}
DEBUG:root:Unifying object: object0{} with: object15{}
DEBUG:root:New substitution: []
DEBUG:root:Unifying *params: tuple2[object0{}, object1{}] with tuple14[<type 'int'>, <type 'str'>]
DEBUG:root:Unifying two tuples...
DEBUG:root:Unifying object: object0{} with: <type 'int'>
DEBUG:root:Unifying object: object1{} with: <type 'str'>
DEBUG:root:New substitution: [object1 >> <type 'str'>,object0 >> <type 'int'>,]
DEBUG:root:Sub is: [object1 >> <type 'str'>,object0 >> <type 'int'>,]
DEBUG:root:Applying sub to: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Env: {'*return': <type 'int'>}
DEBUG:root:Env: {'*return': <type 'int'>, '*params': tuple18[<type 'int'>, <type 'str'>]}
DEBUG:root:Unified type: object17{'*return': <type 'int'>, '*params': tuple18[<type 'int'>, <type 'str'>]}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <type 'int'>}
DEBUG:root:Given type: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Environment: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <type 'int'>}
DEBUG:root:Arg types: [<type 'int'>]
DEBUG:root:Applied type: object21{'*return': object20{}, '*params': tuple19[<type 'int'>]}
DEBUG:root:Unifying object: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]} with: object21{'*return': object20{}, '*params': tuple19[<type 'int'>]}
DEBUG:root:Unifying *return: object0{} with object20{}
DEBUG:root:Unifying object: object0{} with: object20{}
DEBUG:root:New substitution: []
DEBUG:root:Unifying *params: tuple2[object0{}, object1{}] with tuple19[<type 'int'>]
DEBUG:root:Unifying two tuples...
DEBUG:root:New substitution: [tuple2 >> <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>,]
DEBUG:root:Sub is: [tuple2 >> <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>,]
DEBUG:root:Applying sub to: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Env: {'*return': object23{}}
DEBUG:root:Env: {'*return': object23{}, '*params': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>}
DEBUG:root:Unified type: object22{'*return': object23{}, '*params': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>}
DEBUG:root:Given type: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Environment: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>}
DEBUG:root:Arg types: [<<Type Error: Undefined>>, <<Type Error: Undefined>>]
DEBUG:root:Applied type: object26{'*return': object25{}, '*params': tuple24[<<Type Error: Undefined>>, <<Type Error: Undefined>>]}
DEBUG:root:Unifying object: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]} with: object26{'*return': object25{}, '*params': tuple24[<<Type Error: Undefined>>, <<Type Error: Undefined>>]}
DEBUG:root:Unifying *return: object0{} with object25{}
DEBUG:root:Unifying object: object0{} with: object25{}
DEBUG:root:New substitution: []
DEBUG:root:Unifying *params: tuple2[object0{}, object1{}] with tuple24[<<Type Error: Undefined>>, <<Type Error: Undefined>>]
DEBUG:root:Unifying two tuples...
DEBUG:root:Unifying object: object0{} with: <<Type Error: Undefined>>
DEBUG:root:Unifying object: object1{} with: <<Type Error: Undefined>>
DEBUG:root:New substitution: [object1 >> <<Type Error: Undefined>>,object0 >> <<Type Error: Undefined>>,]
DEBUG:root:Sub is: [object1 >> <<Type Error: Undefined>>,object0 >> <<Type Error: Undefined>>,]
DEBUG:root:Applying sub to: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Env: {'*return': <<Type Error: Undefined>>}
DEBUG:root:Env: {'*return': <<Type Error: Undefined>>, '*params': tuple28[<<Type Error: Undefined>>, <<Type Error: Undefined>>]}
DEBUG:root:Unified type: object27{'*return': <<Type Error: Undefined>>, '*params': tuple28[<<Type Error: Undefined>>, <<Type Error: Undefined>>]}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <<Type Error: Undefined>>}
DEBUG:root:Given type: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Environment: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <<Type Error: Undefined>>}
DEBUG:root:Arg types: [<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]
DEBUG:root:Applied type: object31{'*return': object30{}, '*params': tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]}
DEBUG:root:Unifying object: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]} with: object31{'*return': object30{}, '*params': tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]}
DEBUG:root:Unifying *return: object0{} with object30{}
DEBUG:root:Unifying object: object0{} with: object30{}
DEBUG:root:New substitution: []
DEBUG:root:Unifying *params: tuple2[object0{}, object1{}] with tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]
DEBUG:root:Unifying two tuples...
DEBUG:root:New substitution: [tuple2 >> <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>,]
DEBUG:root:Sub is: [tuple2 >> <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>,]
DEBUG:root:Applying sub to: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Env: {'*return': object33{}}
DEBUG:root:Env: {'*return': object33{}, '*params': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
DEBUG:root:Unified type: object32{'*return': object33{}, '*params': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
DEBUG:root:Given type: object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}
DEBUG:root:Environment: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
DEBUG:root:Arg types: []
DEBUG:root:Applied type: object36{'*return': object35{}, '*params': tuple34[]}
DEBUG:root:Unifying object: object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]} with: object36{'*return': object35{}, '*params': tuple34[]}
DEBUG:root:Unifying *return: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]} with object35{}
DEBUG:root:Unifying object: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]} with: object35{}
DEBUG:root:New substitution: []
DEBUG:root:Unifying *params: tuple4[] with tuple34[]
DEBUG:root:Unifying two tuples...
DEBUG:root:New substitution: []
DEBUG:root:Sub is: []
DEBUG:root:Applying sub to: object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}
DEBUG:root:Env: {'*return': object39{}}
DEBUG:root:Env: {'*return': object39{}, '*params': tuple42[object40{}, object41{}]}
DEBUG:root:Env: {'*return': object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}}
DEBUG:root:Env: {'*return': object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}, '*params': tuple43[]}
DEBUG:root:Unified type: object37{'*return': object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}, '*params': tuple43[]}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 's': object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
DEBUG:root:Given type: object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}
DEBUG:root:Environment: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 's': object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
DEBUG:root:Arg types: [object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, <type 'int'>, <type 'str'>]
DEBUG:root:Applied type: object46{'*return': object45{}, '*params': tuple44[object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, <type 'int'>, <type 'str'>]}
DEBUG:root:Unifying object: object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]} with: object46{'*return': object45{}, '*params': tuple44[object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, <type 'int'>, <type 'str'>]}
DEBUG:root:Unifying *return: object10{} with object45{}
DEBUG:root:Unifying object: object10{} with: object45{}
DEBUG:root:New substitution: []
DEBUG:root:Unifying *params: tuple12[object6{}, object7{}, object8{}] with tuple44[object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, <type 'int'>, <type 'str'>]
DEBUG:root:Unifying two tuples...
DEBUG:root:Unifying object: object6{} with: object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
DEBUG:root:Unifying object: object7{} with: <type 'int'>
DEBUG:root:Unifying object: object8{} with: <type 'str'>
DEBUG:root:New substitution: [object8 >> <type 'str'>,object7 >> <type 'int'>,object6 >> object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]},]
DEBUG:root:Sub is: [object8 >> <type 'str'>,object7 >> <type 'int'>,object6 >> object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]},]
DEBUG:root:Applying sub to: object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}
DEBUG:root:Env: {'*return': object48{}}
DEBUG:root:Env: {'*return': object48{}, '*params': tuple49[object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, <type 'int'>, <type 'str'>]}
DEBUG:root:Unified type: object47{'*return': object48{}, '*params': tuple49[object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, <type 'int'>, <type 'str'>]}
DEBUG:root:Env: {'g': object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}, 'r': object48{}, 'S': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, 'f': object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}, 'x': <<Type Error: Undefined>>, 'z': <type 'int'>, 's': object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}, 'y': <type 'str'>, 'q': <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>}
INFO:root:Analyzed Tree:
INFO:root:  tests/src/demo.py
    Assign
      x : <<Type Error: Undefined>>
      y : <<Type Error: Undefined>>
    Assign
      y : <type 'int'>
      1 : <type 'int'>
    Assign
      z : <type 'int'>
      y : <type 'int'>
    Assign
      y : <type 'str'>
      "str" : <type 'str'>
    S : object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
      Parameters : tuple2[object0{}, object1{}]
        x : object0{}
        y : object1{}
      return
        x : object0{}
    f : object5{'*return': object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}, '*params': tuple4[]}
      Parameters : tuple4[]
      return
        S : object3{'*return': object0{}, '*params': tuple2[object0{}, object1{}]}
    g : object13{'*return': object10{}, '*params': tuple12[object6{}, object7{}, object8{}]}
      Parameters : tuple12[object6{}, object7{}, object8{}]
        x : object6{}
        y : object7{}
        func : object8{}
      return
        func : object10{}
    Assign
      q : <type 'int'>
      S : <type 'int'>
    Assign
      q : <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>
      S : <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple19[<type 'int'>]>>
    Assign
      q : <<Type Error: Undefined>>
      S : <<Type Error: Undefined>>
    Assign
      q : <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>
      S : <<Type Error: Conflicting types: tuple2[object0{}, object1{}] and tuple29[<<Type Error: Undefined>>, <type 'int'>, <type 'str'>]>>
    Assign
      s : object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}
      f : object38{'*return': object39{}, '*params': tuple42[object40{}, object41{}]}
    Assign
      r : object48{}
      g : object48{}

