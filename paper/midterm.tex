\documentclass{article}
\usepackage{amsmath}

\title{Analysis of Algorithms Midterm}
\author{Jay R Bolton}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\begin{document}
\maketitle

\begin{enumerate}

\item[\textbf{1}]

	\begin{enumerate}

		\item[\textbf{\emph{{(a)}}}]

		\begin{align*}
			& T(n) = 3T(n/4) + n\ log\ n \\
			& a = 3, b = 4, f(n) = n\ log\ n \\
			& f(n) = \Omega(n^{log_4 3 + e})\ \ \text{ case 3} \\
			& (n\ log\ n) / (n^{log_4 3}) \ \ \text{ (it is polynomially larger)}\\
			& \text{Regularity condition:} \\
			& 3(n/4)log(n/4) \leq c \cdot n\ log\ n \\
			& n(3/4)(log\ n - log\ 4) \leq c \cdot n\ log\ n \\
			& 3/4\ n\ log\ n - 3/4\ n\ log\ 4 \leq c \cdot n\ log\ n \\
			& \text{(Passes)} \\\
			& T(n) = \Theta(n\ log\ n)
		\end{align*}

		\item[\textbf{\emph{{(b)}}}]

		\begin{align*}
			& T(n) = 3T(n/3) + n/3 \\
			& a = 3, b = 3, f(n) = n/3 \\
			& f(n) = \Theta(n^{log_3 3})\ \ \text{ case 2} \\
			& T(n) = \Theta(n\ lg\ n)
		\end{align*}

	\end{enumerate}

\item[\textbf{2}]

	\begin{enumerate}

		\item[\textbf{\emph{{(a)}}}]

		$T(n) = 3T(n/4) + n\ log\ n$

		\begin{verbatim}
                 n log n
          /           |         \
(n/4)log(n/4)  (n/4)log(n/4)  (n/4)log(n/4)
...                  ...          ...
    \end{verbatim}

		Height of tree is $h = log_4 n$, and width of leaves is $n^{log_4 3}$

		$$
		T(n) = \Theta(n^{log_4 3}) + \sum_{i=1}^h 3^i((n / 4^i)\ log\ (n / 4^i))
		$$

		$T(n) = 3T(n/3) + n/3$

		\begin{verbatim}
                     n/3
          /           |         \
     (n/3)/3        (n/3)/3     (n/3)/3
...                  ...          ...
    \end{verbatim}

		Height of tree is $h = log_3 n$, and width of leaves is $n^{log_3 3}$

		$$
		T(n) = \Theta(n) + \sum_{i=1}^h (3^i ((n/3^i)/3)) = \sum_{i=1}^h \frac{n}{3}
		$$

		\item[\textbf{\emph{{(b)}}}]

		\begin{align*}
		& (a) \\
		& T(n) = 3T(n/4) + n\ log\ n \\
		&= \Theta(n^{log_4 3}) + \sum_{i=1}^h 3^i((n / 4^i)\ log\ (n / 4^i)) \\
		&= \Theta(n^{log_4 3}) + \sum_{i=1}^h n\cdot 3^i/4^i \cdot log\ (n / 4^i) \\
		&= \Theta(n^{log_4 3}) + \sum_{i=1}^h n\cdot log (n/4^i) \cdot 3^i/4^i \\
		&= \Theta(n^{log_4 3}) + \sum_{i=1}^h (n\ log\ n - n\ log\ 4^i) \cdot 3^i/4^i \\
		&= \Theta(n^{log_4 3}) + \sum_{i=1}^h 3^i/4^i \cdot n\ log\ n - 3^i / 4^i \cdot n\ log\ 4^i \\
		&= \Theta(n^{log_4 3}) + \sum_{i=1}^h 3^i/4^i \cdot n\ log\ n - \sum_{i=1}^h 3^i / 4^i \cdot n\ log\ 4^i \\
		&= \Theta(n^{log_4 3}) + n\ log\ n \sum_{i=1}^h 3^i/4^i - \sum_{i=1}^h 3^i / 4^i \cdot n\ log\ 4^i \\
		&= \Theta(n^{log_4 3}) + n\ log\ n \sum_{i=1}^h (3/4)^i - n \sum_{i=1}^h (3/4)^i \cdot log\ 4^i \\
		&= \Theta(n^{log_4 3}) + n\ log\ n \sum_{i=1}^h (3/4)^i - n \sum_{i=1}^h (3/4)^i \cdot log\ 4^i \\
		&< \Theta(n^{log_4 3}) + n\ log\ n \sum_{i=1}^{\infty} (3/4)^i - n \sum_{i=1}^h (3/4)^i \cdot log\ 4^i \\
		&= \Theta(n^{log_4 3}) + n\ log\ n \left( \dfrac{1}{1-(3/4)}\right) - n\sum_{i=1}^h (3/4)^i \cdot log\ 4^i \\
		&= \Theta(n^{log_4 3}) + n\ log\ n \cdot 4 - n\sum_{i=1}^h (3/4)^i \cdot log\ 4^i \\
		&= \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - n\sum_{i=1}^h (3/4)^i \cdot log\ 4^i \\
		&= \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - n\sum_{i=1}^h \dfrac{3^i\ log\ 4^i}{4^i} \\
		&= \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - n\sum_{i=1}^h \left(\dfrac{3\ log\ 4}{4}\right)^i \\
		&< \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - n\sum_{i=1}^{\infty} \left(\dfrac{3\ log\ 4}{4}\right)^i \displaybreak[3]\\
		&= \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - n\left(\dfrac{1}{1 - (3\ log\ 4/4)}\right) \\
		&\approx \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - n \cdot 0.15 \\
		&= \Theta(n^{log_4 3}) + \Theta(n\ log\ n) - \Theta(n) \\
		&\leq 3 \cdot \Theta(n\ log\ n) \\
		&= \mathcal{O}(n\ log\ n)
		\end{align*}

		\begin{align*}
		& (b) \\
		& T(n) = 3T(n/3) + n/3 \\
		& = \Theta(n) + \sum_{i=1}^h \frac{n}{3} \\
		& = \Theta(n) + h \cdot (n/3) \\
		& = \Theta(n) + (log_3 n) \cdot (n/3) \\
		& = \Theta(n) + n/3\ log_3 n \\
		& = \Theta(n) + \mathcal{O}(n\ lg\ n) \\
		& = \mathcal{O}(n\ lg\ n) \\
		\end{align*}

		\item[\textbf{\emph{{(c)}}}]

		For (a), where $T(n) = \Theta(n\ log\ n)$:

		Inductive hypothesis: $T(n) \leq c \cdot n\ log\ n$ for $\mathcal{O}$ and $T(n) \geq c \cdot n\ log\ n$ for $\Omega$.

		Induction for $\mathcal{O}$:

		\begin{align*}
		& T(n) \leq 3c(n/4)\ log\ (n/4) + n\ log\ n \\
		&  = (3/4)cn(log\ n - log\ 4) + n\ log\ n \\
		&  = 3/4\cdot cn\ log\ n - 3/4\cdot cn\ log\ 4 + n\ log\ n \\
		&  = 3/4\cdot cn\ log\ n - n(3/4\cdot c\ log\ 4) + n\ log\ n \\
		&  = 3/4\cdot cn\ log\ n - nd + n\ log\ n \\
		&  \leq 3/4\cdot cn\ log\ n + n\ log\ n \\
		&  \leq cn\ log\ n \ \ \ \ \ \text{with $c \geq 4$}
		\end{align*}

		Induction for $\Omega$:

		\begin{align*}
		& T(n) \geq 3c(n/4)\ log\ (n/4) + n\ log\ n \\
		&  = 3/4\cdot cn\ log\ n - nd + n\ log\ n \\
		&  \geq cn\ log\ n \ \ \ \ \ \ \text{ with $c \leq 1$}
		\end{align*}

		For (b), where $T(n) = \Theta(n)$:

		Inductive hypothesis: $T(n) = c \cdot n\ lg\ n$ for $\Theta$.

		Induction for $\mathcal{O}$:

		\begin{align*}
		& T(n) \leq 3(c(n/3)lg(n/3)) + n/3 \\
		& = cn\ lg(n/3) + n/3 \\
		& = cn\ lg\ n - cn\ lg\ 3 + n/3 \\
		& \leq cn\ lg\ n  \\
		\end{align*}

		Induction for $\Omega$:

		\begin{align*}
		& T(n) \geq 3(c(n/3)lg(n/3)) + n/3 \\
		& = cn\ lg(n/3) + n/3 \\
		& = cn\ lg\ n - cn\ lg\ 3 + n/3 \\
		& \geq cn\ lg\ n \ \ \ \ \ \text{ with $c \leq \frac{1}{6}$}\\
		\end{align*}

		($1/6 \cdot lg\ 3$  is less than $1/3$.)

		\item[\textbf{\emph{{(d)}}}]

		Yay!

	\end{enumerate}

\item[\textbf{3}]

	\begin{enumerate}

		\item[\textbf{\emph{{(a)}}}]

		\[ \begin{matrix}
		2 & 3 & 4 & 5\\
		8 & 9 & 12 & \infty \\
		14 & \infty & \infty & \infty  \\
		16 & \infty & \infty & \infty 
		\end{matrix} \]

		\item[\textbf{\emph{{(b)}}}]

		Y[1,1] will be the least element in the matrix (least of the least of the
		columns and least of the least of the rows). If it is a singleton tableau,
		then Y[1,1] is the only populated cell. If Y[1,1] is infinity/null, then
		there is no least element and thus no elements.

		If Y[1,1] contains a non-null element then that means we have a least
		element, so m and n are 1 and our tableau is non-empty.

		\item[\textbf{\emph{{(c)}}}]

My pseudocode ended up being some kind of strange imperative haskell. I hope
it's readable.

\begin{verbatim}
extract_min t:
  min := t[0,0]
  t[0,0] := infinity
  percolate t (1,1)
  return min

percolate t (i,j):
  (i',j') := (i,j)
  (right?, below?) := (j+1 <= t.n, i+1 <= t.m)
  if below? and t[i,j] > t[i+1,j]   then (i',j') := (i+1,j)
  if right? and t[i',j'] > t[i,j+1] then (i',j') := (i,j+1)
  if i' != i or j' != j:
    swap t[i,j] t[i',j']
    percolate t (i',j')
\end{verbatim}

And here it is in pseudo-haskell. It felt more awkward than the
imperative, but maybe I just didn't do it well.

\begin{minipage}{\linewidth}
\begin{verbatim}
extract_min t = (t[0,0], percolate (replace t (0,0) infinity) 0 0)

percolate t (i,j) 
 | has_b && t[i,j] > b =
    if has_r && b > r then continue (i,j+1)
    else continue (i+1,j)
 | has_r && t[i,j] > r = continue (i,j+1) 
 | otherwise t
    where
    (has_r, has_b) = (j+1 <= t.n, i+1 <= t.m)
    (r, b) = (t[i,j+1], t[i+1,j])
    continue (i',j') = percolate (swap t[i,j] t[i',j']) (i',j')

\end{verbatim}
\end{minipage}

To prove \texttt{extract\_min}, our main goal will be to prove percolate. The parameter
\texttt{t} is passed as a young tableau, so \texttt{min}, being \texttt{t[0,0]}
is the least element of t and is returned. \texttt{t[0,0]} is replaced with
infinity and then \texttt{percolate} is called on \texttt{t}.

Loop invariant (inductive hypothesis) of \texttt{percolate}: at the start of the function, the young tableau consisting of \texttt{t[0,0]} with maximum element \texttt{t[i,j]} is a young tableau.

Initialization (base case): \texttt{percolate} is first called on \texttt{t[0,0]}, making
\texttt{i = 0} and \texttt{j = 0}. So we have a singleton young tableau with
infinity as its only element, which is trivially a young tableau.

Maintenance (induction): we assume the loop invariant holds prior to the recursive call with \texttt{(i,j)}. The result of the subsequent code is dependent on some cases:
\begin{enumerate}
\item \texttt{t[i,j]} is greater than the cell directly below it (\texttt{t[i+1,j]}). This condition then has two subcases:

	\begin{enumerate}
	\item \texttt{t[i+1,j]} is greater than the cell directly right
	(\texttt{t[i,j+1]}). In this case, \texttt{t[i,j]} is swapped with
	\texttt{t[i,j+1]}. Now we have the tableau \texttt{t} with elements from
	\texttt{t[0,0]} up to the maximum \texttt{t[i,j]}. By the inductive
	hypothesis, \texttt{t[i,j] > t[i,j-1]} (unless \texttt{i==0}) and
	\texttt{t[i,j] > t[i-1]} (unless \texttt{i==0}) so our loop invariant holds.

	\item otherwise, we swap \texttt{t[i+1,j]} with \texttt{t[i,j]}. By the
	inductive hypothesis, \texttt{t[i,j] > t[i-1,j]} and by our conditional
	\texttt{t[i,j] <= t[i,j+1]}, so our loop invariant holds.

	\end{enumerate}

\item Else if the cell directly right (\texttt{t[i,j+1]}) is greater than our
current cell (\texttt{t[i,j]}) and greater than or equal to the one directly
below (\texttt{t[i+1,j]}), then we swap \texttt{t[i,j]} and \texttt{t[i,j+1]}.
By the inductive hypothesis, \texttt{t[i,j] >= t[i,j-1]}, unless
\texttt{j == 0}. Also by the inductive hypothesis, \texttt{t[i,j] >= t[i-1,j]}
unless \texttt{i == 0}. Thus the loop invariant holds.

\end{enumerate}

	\item[\textbf{\emph{{(d)}}}]

	\begin{align*}
	& T(m+n) = T(m+n-1) + \mathcal{O}(1) \\
	& T(p) = T(p-1) + \mathcal{O}(1) \\
	& = \sum_1^{p} \mathcal{O}(1) \\
	& = p \cdot \mathcal{O}(1) \\
	& = (m + n) \cdot \mathcal{O}(1) \\
	& = \mathcal{O}(m + n)
	\end{align*}

	\end{enumerate}

\end{enumerate}

\end{document}
